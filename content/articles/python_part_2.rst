:title: Python Syntax
:date: 2017-05-28
:modified: 2017-05-28
:author: Artur K.
:category: Programming
:tags: linux, python
:slug: python_syntax

.. contents:: **Содержание**
   :depth: 3

----

В `предыдущей статье <{filename}python_part_1.rst>`_ рассмотрели достоинства и
недостатки ЯП **Python**, установили интерпретатор *python3* и написали первую программу
*Hello, world!*.

В сегодняшней статье расммотрим синтаксис языка, модель динамической типизации и
базовые типы данных, где подробно рассмотрим числа и строки.

----

==========================
**Синтаксис языка Python**
==========================

------------------
**Идентификаторы**
------------------

Идентификаторы в **Python** - это имена, используемые для определения переменных,
функций, классов, модулей и других объектов. Идентификатор начинается с букв A-Z или a-z,
либо знака подчеркивания (_), после чего следует ноль или больше букв, знаков
подчеркивания или цифр от 0 до 9.

*Никогда не создавайте свою собственную переменную с именем (_), так как это имя
зарезервировано самим интерпретатором.*

В идентификаторах **Python** не используются знаки @, $ и %.
Так же – **Python** чувствителен к регистру символов, т.е. *Manpower* и *manpower*
являются двумя различными именами (*идентификаторами*).

---------------------------
**Зарезервированные имена**
---------------------------

В списке ниже приведены имена, которые зарезервированы в **Python**, и их
использование не допускается в использовании определения констант, переменных
или любых других пользовательских именах. Все зарезервированные слова содержат
только строчные буквы:

+----------+---------+--------+--------+-------+
| and      | del     | from   | not    | while |
+----------+---------+--------+--------+-------+
| as       | elif    | global | or     | with  |
+----------+---------+--------+--------+-------+
| assert   | else    | if     | pass   | yield |
+----------+---------+--------+--------+-------+
| break    | except  | import | print  |       |
+----------+---------+--------+--------+-------+
| class    | exec    | in     | raise  |       |
+----------+---------+--------+--------+-------+
| continue | finally | is     | return |       |
+----------+---------+--------+--------+-------+
| def      | for     | lambda | try    |       |
+----------+---------+--------+--------+-------+

Список зарезервированых имен можно так же получить следующим образом:

.. code::

    import keyword
    print(keyword.kwlist)

--------------------
**Строки и отступы**
--------------------

Одно из самых важных замечаний для тех, кто начал изучать **Python** – это то,
что в нём при обозначении границ блоков кода для классов и функций, а так же
для управления потоками, не используются привычные некоторым фигурные скобки.
Вместо этого – в **Python** используются отступы строк.

Количество отступов в начале строки не имеет значения, но все операторы внутри
такого блока должны иметь их одинаковое количество.

Например, оба блока в примере ниже выполнены правильно:

.. code::

    if True:
      print "True"
    else:
      print "False"

А вот второй блок в следующем примере – приведёт к ошибке интерпретатора
**IndentationError: unexpected indent**:

.. code::

    if True:
      print "Answer"
      print "True"
    else:
      print "Answer"
        print "False"

Таким образом, все линии, имеющие одинаковое количество отступов от начала
строки буду формировать блок кода.

---------------------------
**Многострочные операторы**
---------------------------

Операторы и операнды в Python как правило заканчиваются новой строкой.
Однако, есть возможность использовать знак продолжения строки (\) для обозначения
того, что строка продолжается.
Например:

.. code::

  total = item_one + \
          item_two + \
          item_three

Операнды, заключённые в скобки [], {} или () не нуждаются в использовании
такого символа. Например:

.. code::

    days = ['Monday', 'Tuesday', 'Wednesday',
    'Thursday', 'Friday']

Что бы представлять себе разницу между “оператором” и “операндом” при выполнении
“операции” – посмотрите на эту картинку:

.. figure:: /images/operation.gif
    :height: 122px
    :width: 249px
    :scale: 100%
    :align: center
    :alt: Operation

--------------------
**Кавычки в Python**
--------------------

В Python используются одинарные ('), двойные (") и тройные (''' или """) кавычки
для обозначения строковых литералов (или просто – строк).

Тройные кавычки могут использоваться для охвата многострочного текста.

.. code::

    word = 'word'
    sentence = "This is a sentence."
    paragraph = """This is a paragraph. It is
    made up of multiple lines and sentences."""

------------------------
**Комментарии в Python**
------------------------

Хеш-тег (#), который не находится внутри строки задаёт начало комментария.
Все символы после # и до конца строки являются частью комментария, и **Python**
игнорирует их.

.. code::

    #!/usr/bin/python

    # First comment
    print("Hello, Python!"); # second comment

Приведённый выше код даст такой результат:

.. code::

    Hello, Python!

Комментарии так же можно размещать и на одной строке после операторов или
выражения, например:

.. code::

    name = "Madisetti" # This is again comment

Многострочные комментарии можно создать так:

.. code::

    # This is a comment.
    # This is a comment, too.
    # This is a comment, too.
    # I said that already.

Или так:

.. code::

    '''Line one
    second line
    third line'''

-----------------
**Пустые строки**
-----------------

Пустые строки, или строки содержащие только пробелы, или строки с комментариями,
игнорируются интерпретатором.

В интерактивной сессии интерпретатора, необходимо ввести пустую строку для
завершения многострочного оператора.

Более подробно о том, как правильно оформлять код **Python** можно прочитать в
`PEP8 <http://pep8.ru/doc/pep8/>`_!

*PEP (python enhanced proposal) — заявки на улучшение языка Python.*

----

=================================
**Модель динамической типизации**
=================================

В одном из примеров мы не объявляли тип переменной либо её саму:

.. code::

    name = "Madisetti"

У вас может возникнуть вопрос, как же интерператор **Python** узнает, что речь идет
о строке? И вообще, как **Python** узнает, что есть что?

Для того, чтобы ответить на эти вопросы, необходимо рассмотреть как работает
динамическая типизация в **Python**. Типы данных в **Python** определяются автоматически
во время выполнения, а не в результате объявлений в программном коде. Это означает,
что вам не требуется заранее объявлять переменные (эту концепцию проще понять, если
иметь в виду, что все сводится к переменным, объектам и ссылкам между ними).

**Создание переменной**

Переменная (т.е. имя или идентификатор), такая как *name*, создается автоматически,
когда в программном коде ей впервые присваивается некоторое значение. Все последующие
операции присваивания просто изменяют значение, ассоциированное с уже созданным
именем.

**Типы переменных**

Переменные не имеют никакой информации о типе или ограничениях, связанных с ними.
Понятие типа присущие объектам, а не именам. Переменные универсальны по своей природе -
они всегда являются всего лишь ссылками на конкретные объекты в конкретные моменты
времени.

**Использование переменной**

Когда переменная участвует в выражении, ее имя замещается объектом, на который
она в настоящий момент ссылается, независимо от того, что это за объект. Кроме
того, прежде чем переменную можно будет использовать, ей должно быть присвоено
значение - использование неицициализированной переменной приведет к ошибке
(*NameError: name 'name' is not defined*).

Для того чтобы понимать что происходит при присваивании некого значения переменной,
рассмотрим такой пример:

.. code::

    a = 3

**Python** выполнит эту инструкцию в три этапа, концептуально.

1. Cоздается объект, представляющий число 3.
2. Создается пременная *a*, если она еще отсутствует.
3. В переменную *a* записывается ссылка на вновь созданный объект, представляющий число 3.

**Информация о типе хранится в объекте, но не в переменной.**

Допустим, у нас есть следующий пример:

.. code::

    a = 3
    a = 'spam'
    a = 1.23

Как уже указывалось ранее, имена не имеют типов, тип - это свойство объекта, а не
имени. В предыдущем листинге просто изменяется ссылка на объект. Все что можно
сказать о перменных в языка **Python** - это то, что они создаются на конкретные
объекты в конкретные моменты времени.

Объекты знают, к какому типу они относятся, - каждый объект содержит поле, в котором
хранится информация о его типе. Целочисленный объект 3, например, будет содержать
значение 3 плюс информацию, которая сообщит интерпретатору **Python**, что объект
является целым числом (строго говоря - это указатель на объект с названием *int*).
Описатель типа для строки 'spam' указывает на строковой тип (с именем *str*).
Поскольку информация о типе хранится в объектах, ее не нужно хранить в переменных.

У кого-то может возникнуть вопрос: что происходит с прежними значениями, когда
выполняется новое присваивание?
Например, что произойдет с объектом 3 после выполнения следующих инструкций:

Основная выгода от сборки мусора состоит в том, что вы может свободно распоряжаться
объектами, не будучи обязаны освбождать память в своем сценарии.

.. code::

    a = 3
    a = 'spam'

Когда имя ассоциируется с новым объектом, интепретатор **Python** освобождает
память, занимаемую предыдущим объектом (если на него не ссылается какое-либо другое
имя или объект). Такое автоматическое освобождение памяти, занимаемой объектами,
называется *сборкой мусора (garbage collection)*.

----------------------
**Разделяемые ссылки**
----------------------

До сих пор мы рассматривали вариант, когда ссылка на объект присваивается
единственной переменной. Теперь введем в действие еще одну переменную и посмотрим,
что происходит с именами и объектами в это случае:

.. code:

    a = 3
    b = a

.. figure:: /images/links-1.png
    :height: 123px
    :width: 556px
    :scale: 100%
    :align: center
    :alt: Python Links to one object

В языке **Python** это называется *разделяемая ссылка* - несколько имен ссылаются
на один и тот же объект.

Далее добавим еще одну инструкцию:

.. code::

    a = 3
    b = a
    b = 'spam'

В результате выполнения этой инструкции создается новый объект, представляющий
строку 'spam', а ссылка на него записывается в переменную *a*. Однако эти действия
не оказывают влияния на переменную *b* - она по-прежнему ссылается на первый
объект, целое число 3. В результате схема взаимоотношений приобретает вид:

.. figure:: /images/links-2.png
    :height: 188px
    :width: 554px
    :scale: 100%
    :align: center
    :alt: Python Links to two objects

То же самое произошло бы, если бы ссылка на объект 'spam' вместо переменной *a*
была присвоена переменной *b* - изменилась бы только переменная *b*, но не *а*.
Аналогичная ситуация возникает, даже если тип объекта не изменяется.
Например, рассмотрим следующие три инструкции:

.. code::

    a = 3
    b = a
    a = a + 2

В этой последовательности происходит те же самые события: интепретатор **Python**
создает переменную *a* и записывает в нее ссылку на объект *3*. После этого он
создает переменную *b* и записывает в нее ту же ссылку, что хранится в переменной
*a*. Наконец, последняя инструкция создает совершенно новый объект (в данном случае -
целое число 5, которое является результатом выполнения операции сложения). Это не
приводит к изменению переменной *b*. В действительности нет никакого способа
перезаписать значение объекта 3, целые числа относятся к категории неизменяемых
(*подробнее о категориях и типов данных далее*), и поэтому эти объекты невозможно
изменить.

-------------------------------------------
**Разделяемые ссылки и изменяемые объекты**
-------------------------------------------

Как будет показано дальше в этом цикле статей, существуют такие объекты и операции,
которые приводят к изменению самих объектов. Например, операции присваивания значения
элементу списка фактически изменяют сам список вместо того, чтобы создавать совершенно
новый объект списка. При работе с объектами, допускающими такие изменения, необходимо
быть особенно внимательными при использовании разделяемых ссылок, так как изменение
одного имени может отразиться на других именах.

Возьмем в качестве примера объекты списков (будут рассмотрены подробно в следующей
части). Списки, поддерживают возможность присваивания значений элементам, - это
просто коллекция объектов, которые в программном коде записываются как литералы
в квадратных скобках:

.. code::

    l1 = [2, 3, 4]
    l2 = l1

В данном случае *l1* - это список, содержащий объекты 2, 3 и 4. Доступ к элементам
списка осуществляется по их индексам; так, *l1[0]* - ссылается на объект 2, т.е. на
первый элемент в списке *l1*. Cписки являются полноценными объектами, такими же,
как целые числа и строки. После выполнения двух приведенных выше инструкций
*l1* и *l2* будут ссылаться на один и тот же объект, так же, как переменные *a* и
*b* в примере выше. Точно так же, если теперь добавить еще одну инструкцию:

.. code::

    l1 = 24

Переменная *l1* будет ссылаться на другой объект, а l2 по-прежнему будет ссылаться
на первоначальный список. Однако если синтаксис последней инструкции немного изменить,
эффект получится другим:

.. code::

    l1 = [2, 3, 4]
    l2 = l1
    l1[0] = 24

    l1 # Переменная l1 изменилась
    [24, 3, 4]
    l2 # Но так же изменилась и переменная l2
    [24, 3, 4]

Здесь мы не изменяем сам объект *l1*, изменяется компонент объекта, на который
ссылается *l1*. Данное изменение затронуло часть самого объекта списка. Поскольку
объект списка разделяется разными переменными, то изменения в самом списке затрагивают
не только *l1*, т.е. следует понимать, что такие изменения могут сказываться в
других частях программы. В этом примере изменения обнаруживаются также в переменной
*l2*, потому что она ссылается на тот же самый объект, что и *l1*. Здесь мы фактически
не изменяли *l2*, но значение этой переменной изменилось.

Это поведение по умолчанию: если вас оно не устраивает, можно потребовать от
интерпретатора, чтобы вместо создания ссылок она выполнял копирование объектов.
Скопировать список можно несколькими способами, включая встроенную функцию *list* и
модуль *copy* из стандартной библиотеки. Однако самым стандартным способом
копирования является получение среза (так же будет рассмотрено в следующих частях)
от начала и до конца списка.

.. code::

    l1 = [2, 3, 4]
    l2 = l1[:] # Создание копии списка l1
    l1[0] = 24

    l1
    [24, 3, 4]
    l2 # Не изменился
    [2, 3, 4]

**Будьте внимательны**, что способ, основанный на получении среза, неприменим в
случае с другими изменяемым базовым типом - со словарем (будет рассмотрен подробно
в следущей части), потому что словарь не является последовательностью. Чтобы
скопировать словарь, необходимо воспользоваться методом X.copy(). Следует также
отметить, что модуль *copy* из стандартной библиотеки имеет в своем составе
универсальную функцию, позволяющую копировать объекты любых типов, включая
вложенные структуры (например, словари с вложенными списками).

.. code::

    import copy
    x = copy.copy(y) # Создание "поверхностной" копии любого объекта y
    x = copy.deepcopy(y) # Создание полной копии: копируются все вложенные части

----------------------------------
**Разделяемые ссылки и равенство**
----------------------------------

Возможность сборки мусора, описанная ранее, может оказаться более принципиальным
понятием, чем литералы для объектов некоторых типов.

.. code::

    x = 42
    x = "shrubbery" # Объект 42 теперь уничтожен?

Так как интерпретатор **Python** кэширует и повторно использует малые целые числа и
небольшие строки, объект 42 скорее всего не будет уничтожен. Он, вероятнее всего,
останется в системной таблице для повторного использования, когда вы вновь сгенерируете
число 42 в программном коде. Однако большинство объектов уничтожаются немедленно,
как только будет потеряна последняя ссылка, особенно те, к которым применение
механизма кэширования не имеет смысла.

Согласно модели ссылок в языке **Python**, существует два разных способа выполнять
проверку равенства.

.. code::

    l = [1, 2, 3]
    n = l # n и l - ссылки на один и тот же объект
    l == n # Одно и то же значение
    True
    l is n # Один и тот же объект
    True

Первый способ, основанный на использовании оператора ==, проверяет, равны ли значения
объектов. В языке **Python** практически всегда используется именно этот способ.
Второй способ, основанный на использовании оператора *is*, проверяет идентичность
объектов. Он возвращает значение *True*, только если оба имени ссылаются на один и
тот же объект, вследствие этого он является более строгой формой проверки равенства.

На самом деле оператор *is* просто сравнивает указатели, которые реализуют ссылки,
и тем самым может использоваться для выявления разделяемых ссылок в программном
коде. Он возвращает значение *False*, даже если имена ссылаются на эквивалентные,
но разные объекты, как, например, в следующем случае, когда выполняются два
различных литеральных выражения:

.. code::

    l = [1, 2, 3]
    n = [1, 2, 3] # n и l ссылаются на разные объекты
    l == n # Одно и то же значение
    True
    l is n # Но разные объекты
    False

Посмотрим, что происходит, если те же самые действия выполняются над малыми целыми
числами:

.. code::

    x = 42
    y = 42 # Должно получиться два разных объекта
    x == y
    True
    x is y # Тот же самый объект: кэширование в действии!
    True

В этом примере переменные *x* и *y* должны быть равны, но не эквивалентны, потому
что было выполнено два разных литеральных выражения. Однако из-за того, что малые
целые числа и строки кэшируются и используются повторно, оператор *is* сообщает,
что переменные ссылаются на один и тот же объект.

Фактически если вы действительно хотите взглянуть на работу внутренних механизмов,
вы всегда можете запросить у интерпретатора количество ссылок на объект: функция
*getrefcount* из стандартного модуля *sys* возвращает значение поля счетчика ссылок
в объекте.

.. code::

    import sys
    sys.getrefcount(1) # 810 указателей на этот участок памяти
    810

----

=======================
**Базовые типы данных**
=======================

Данные в языке Python представлены в форме объектов – либо встроенных,
предоставляемых языком Python, либо объектов, которые мы создаем с применением
конструкций языка Python или других инструментов, таких как библиотеки расширений,
написанные на языке C. Если говорить по сути, объекты – это области памяти со
значениями и ассоциированными с ними наборами операций.
На языке Python объекты можно разложить на такие составляющие, как модули,
инструкции, выражения и объекты; при этом:

1. Программы делятся на модули.
2. Модули содержат инструкции.
3. Инструкции состоят из выражений.
4. Выражения создают и обрабатывают объекты.

---------------
**Типы данных**
---------------

Краткий обзор встроенных типов данных в **Python** можно увидеть в таблице ниже,
в ней представлены не все типы данных, но часто используемые.

+-------------+---------------------------------------+
| Тип объекта | Пример литерала/создания              |
+=============+=======================================+
| Числа       | 1234, 3.1415, 3+4j, Decimal, Fraction |
+-------------+---------------------------------------+
| Строки      | ‘spam’, “guido’s” , b’a\x01c’         |
+-------------+---------------------------------------+
| Списки      | [1, [2, ‘three’], 4]                  |
+-------------+---------------------------------------+
| Словари     | {‘food’: ‘spam’, ‘taste’: ‘yum’}      |
+-------------+---------------------------------------+
| Кортежи     | (1,’spam’, 4, ‘U’)                    |
+-------------+---------------------------------------+
| Множества   | set(‘abc’), {‘a’, ‘b’, ‘c’}           |
+-------------+---------------------------------------+
| None Type   | None                                  |
+-------------+---------------------------------------+
| Логические  | True, False                           |
+-------------+---------------------------------------+

Все типы данных в **Python** относятся к одной из 2-ух категорий: изменяемые (*mutable*)
и неизменяемые (*unmutable*).
Из предопределенных неизменяемых типов данных **Python** - числа (*int*, *float*,
*complex*), строки (*str*), кортежи (*tuple*), к изменяемым типам относится - списки (*list*),
словари (*dict*), множества (*set*).

Сегодня рассмотрим подробно такие типы данных, как числа и строки.

~~~~~~~~~
**Числа**
~~~~~~~~~

Числа в *python3*: целые, вещественные, комплексные.
Работа с числами и операции над ними.

**Целые числа**

Числа в *python3* ничем не отличаются от обычных чисел. Они поддерживают набор самых
обычных математических операций:

.. figure:: /images/math-operation.png
    :height: 470px
    :width: 909px
    :scale: 100%
    :align: left
    :alt: Math Operation

Пример использования каждой операции и результат:

.. code::

    >>> 5 + 2
    7
    >>> 5 - 2
    3
    >>> 5 * 2
    10
    >>> 5 / 2
    2.5
    >>> 5 // 2
    2
    >>> 5 % 2
    1
    >>> -5
    -5
    >>> abs(-5)
    5
    >>> divmod(5, 2)
    (2, 1)
    >>> 5 ** 2
    25
    >>> pow(5, 2, 5)
    0

Над целыми числами также можно производить битовые операции.

.. figure:: /images/bits-operation.png
    :height: 262px
    :width: 911px
    :scale: 100%
    :align: left
    :alt: Math Operation

Пример использования каждой операции и результат:

.. code::

    >>> 7 | 8
    15
    >>> 7 & 8
    0
    >>> 7 ^ 8
    15
    >>> 7 << 1
    14
    >>> 7 >> 1
    3
    >>> ~7
    -8

Системы счисления.

Для систем с основанием 2, 8, 10 и 16 (двоичная, восьмиричная, десятичная,
шестнадцатиричная) в **Python** предусмотрены встроеные функции.

- **int([object], [основание системы счисления])** - преобразование к целому числу в десятичной системе счисления. По умолчанию система счисления десятичная, но можно задать любое основание от 2 до 36 включительно.
- **bin(x)** - преобразование целого числа в двоичную строку.
- **hex(х)** - преобразование целого числа в шестнадцатеричную строку.
- **oct(х)** - преобразование целого числа в восьмеричную строку.

Пример использования:

.. code::

    >>> int("1") # Переводим строку в число
    1
    >>> int("2.5") # Строка не является целым числом, будет возбуждено исключение:
    ValueError: invalid literal for int() with base 10: '2.5'

    >>> int(3.5) # Применённая к числу с плавающей точкой, отсекает дробную часть
    3

    >>> bin(17)
    '0b10001'

    >>> hex(17)
    '0x11'

    >>> oct(17)
    0o21

    >>> 0b1111
    15

    >>> int('10011', 2)
    19

    >>> int('0b10011', 2)
    19

**Вещественные числа**

Вещественные числа поддерживают те же операции, что и целые. Однако (из-за
представления чисел в компьютере) вещественные числа неточны, и это может
привести к ошибкам:

.. code::

    >>> 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1
    0.7999999999999999

Для высокой точности используют другие объекты (например Decimal и Fraction).

Дополнительные методы для вещественных чисел:

- float.as_integer_ratio() - пара целых чисел, чьё отношение равно этому числу.
- float.is_integer() - является ли значение целым числом.
- float.hex() - переводит float в hex (шестнадцатеричную систему счисления).
- float.fromhex(s) - float из шестнадцатеричной строки.

.. code::

    >>> 3.5.as_integer_ratio()
    (7, 2)
    >>> 12.0.is_integer()
    True
    >>> 12.1.is_integer()
    False
    >>> 1.4.hex()
    '0x1.6666666666666p+0'
    >>> float.fromhex('0x1.5000000000000p+3')
    10.5

**Комплексные числа**

В **Python** встроены также и комплексные числа.

.. code::

    >>> x = complex(1, 2)
    >>> print(x)
    (1+2j)
    >>> y = complex(3, 4)
    >>> print(y)
    (3+4j)
    >>> z = x + y
    >>> print(x)
    (1+2j)
    >>> print(z)
    (4+6j)
    >>> z = x * y
    >>> print(z)
    (-5+10j)
    >>> z = x / y
    >>> print(z)
    (0.44+0.08j)
    >>> print(x.conjugate())  # Сопряжённое число
    (1-2j)
    >>> print(x.imag)  # Мнимая часть
    2.0
    >>> print(x.real)  # Действительная часть
    1.0
    >>> print(x > y)  # Комплексные числа нельзя сравнить
    TypeError: unorderable types: complex() > complex()
    >>> print(x == y)  # Но можно проверить на равенство
    False
    >>> abs(3 + 4j)  # Модуль комплексного числа
    5.0
    >>> pow(3 + 4j, 2)  # Возведение в степень
    (-7+24j)

~~~~~~~~~~
**Строки**
~~~~~~~~~~

Строки в Python - упорядоченные последовательности символов, используемые
для хранения и представления текстовой информации, поэтому с помощью строк
можно работать со всем, что может быть представлено в текстовой форме.

Работа со строками в Python очень удобна. Существует несколько литералов строк,
которые мы сейчас и рассмотрим.

.. code::

    S = 'spam"s'
    S = "spam's"

Строки в апострофах и в кавычках - одно и то же. Причина наличия двух вариантов
в том, чтобы позволить вставлять в литералы строк символы кавычек или апострофов,
не используя экранирование.

**Экранированные последовательности**

Экранированные последовательности позволяют вставить символы, которые сложно ввести с клавиатуры.

.. figure:: /images/spec-symbols.png
    :height: 587px
    :width: 905px
    :scale: 100%
    :align: left
    :alt: Special Symbols

**"Сырые" строки**

Если перед открывающей кавычкой стоит символ 'r' (в любом регистре), то механизм
экранирования отключается.

.. code::

    S = r'C:\newt.txt'

Но, несмотря на назначение, "сырая" строка не может заканчиваться символом
обратного слэша. Пути решения:

.. code::

    S = r'\n\n\\'[:-1]

**Базовые операции со строками**

Конкатенация (сложение):

.. code::

    >>> S1 = 'spam'
    >>> S2 = 'eggs'
    >>> print(S1 + S2)
    'spameggs'

Дублирование строки:

.. code::

    >>> print('spam' * 3)
    spamspamspam

Длина строки (функция len):

.. code::

    >>> len('spam')
    4

Доступ по индексу:

.. code::


    >>> S = 'spam'
    >>> S[0]
    's'
    >>> S[2]
    'a'
    >>> S[-2]
    'a'

Как видно из примера, в Python возможен и доступ по отрицательному индексу,
при этом отсчет идет от конца строки.

Извлечение среза:
Оператор извлечения среза: [X:Y]. X – начало среза, а Y – окончание; символ с
номером Y в срез не входит. По умолчанию первый индекс равен 0, а второй - длине
строки.

.. code::

    >>> s = 'spameggs'
    >>> s[3:5]
    'me'
    >>> s[2:-2]
    'ameg'
    >>> s[:6]
    'spameg'
    >>> s[1:]
    'pameggs'
    >>> s[:]
    'spameggs'

Кроме того, можно задать шаг, с которым нужно извлекать срез.

.. code::

    >>> s[::-1]
    'sggemaps'
    >>> s[3:5:-1]
    ''
    >>> s[2::2]
    'aeg'
