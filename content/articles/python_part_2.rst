:title: Python Syntax
:date: 2017-05-28
:modified: 2017-05-30
:author: Artur K.
:category: Programming
:tags: linux, python
:slug: python_syntax

.. contents:: **Содержание**
   :depth: 3

----

В `предыдущей статье <{filename}python_part_1.rst>`_ рассмотрели достоинства и
недостатки ЯП **Python**, установили интерпретатор *python3* и написали первую программу
*Hello, world!*.

В сегодняшней статье расммотрим синтаксис языка, модель динамической типизации.

----

==========================
**Синтаксис языка Python**
==========================

------------------
**Идентификаторы**
------------------

Идентификаторы в **Python** - это имена, используемые для определения переменных,
функций, классов, модулей и других объектов. Идентификатор начинается с букв A-Z или a-z,
либо знака подчеркивания (_), после чего следует ноль или больше букв, знаков
подчеркивания или цифр от 0 до 9.

*Никогда не создавайте свою собственную переменную с именем (_), так как это имя
зарезервировано самим интерпретатором.*

В идентификаторах **Python** не используются знаки @, $ и %.
Так же – **Python** чувствителен к регистру символов, т.е. *Manpower* и *manpower*
являются двумя различными именами (*идентификаторами*).

---------------------------
**Зарезервированные имена**
---------------------------

В списке ниже приведены имена, которые зарезервированы в **Python**, и их
использование не допускается в использовании определения констант, переменных
или любых других пользовательских именах. Все зарезервированные слова содержат
только строчные буквы:

+----------+---------+--------+--------+-------+
| and      | del     | from   | not    | while |
+----------+---------+--------+--------+-------+
| as       | elif    | global | or     | with  |
+----------+---------+--------+--------+-------+
| assert   | else    | if     | pass   | yield |
+----------+---------+--------+--------+-------+
| break    | except  | import | print  |       |
+----------+---------+--------+--------+-------+
| class    | exec    | in     | raise  |       |
+----------+---------+--------+--------+-------+
| continue | finally | is     | return |       |
+----------+---------+--------+--------+-------+
| def      | for     | lambda | try    |       |
+----------+---------+--------+--------+-------+

Список зарезервированых имен можно так же получить следующим образом:

.. code::

    import keyword
    print(keyword.kwlist)

--------------------
**Строки и отступы**
--------------------

Одно из самых важных замечаний для тех, кто начал изучать **Python** – это то,
что в нём при обозначении границ блоков кода для классов и функций, а так же
для управления потоками, не используются привычные некоторым фигурные скобки.
Вместо этого – в **Python** используются отступы строк.

Количество отступов в начале строки не имеет значения, но все операторы внутри
такого блока должны иметь их одинаковое количество.

Например, оба блока в примере ниже выполнены правильно:

.. code::

    if True:
      print "True"
    else:
      print "False"

А вот второй блок в следующем примере – приведёт к ошибке интерпретатора
**IndentationError: unexpected indent**:

.. code::

    if True:
      print "Answer"
      print "True"
    else:
      print "Answer"
        print "False"

Таким образом, все линии, имеющие одинаковое количество отступов от начала
строки будут формировать блок кода.

---------------------------
**Многострочные операторы**
---------------------------

Операторы и операнды в Python как правило заканчиваются новой строкой.
Однако, есть возможность использовать знак продолжения строки (\\) для обозначения
того, что строка продолжается.
Например:

.. code::

  total = item_one + \
          item_two + \
          item_three

Операнды, заключённые в скобки [], {} или () не нуждаются в использовании
такого символа. Например:

.. code::

    days = ['Monday', 'Tuesday', 'Wednesday',
    'Thursday', 'Friday']

Что бы представлять себе разницу между “оператором” и “операндом” при выполнении
“операции” – посмотрите на эту картинку:

.. figure:: /images/operation.gif
    :height: 122px
    :width: 249px
    :scale: 100%
    :align: center
    :alt: Operation

--------------------
**Кавычки в Python**
--------------------

В Python используются одинарные ('), двойные (") и тройные (''' или """) кавычки
для обозначения строковых литералов (или просто – строк).

Тройные кавычки могут использоваться для охвата многострочного текста.

.. code::

    word = 'word'
    sentence = "This is a sentence."
    paragraph = """This is a paragraph. It is
    made up of multiple lines and sentences."""

------------------------
**Комментарии в Python**
------------------------

Хеш-тег (#), который не находится внутри строки задаёт начало комментария.
Все символы после # и до конца строки являются частью комментария, и **Python**
игнорирует их.

.. code::

    #!/usr/bin/python

    # First comment
    print("Hello, Python!"); # second comment

Приведённый выше код даст такой результат:

.. code::

    Hello, Python!

Комментарии так же можно размещать и на одной строке после операторов или
выражения, например:

.. code::

    name = "Madisetti" # This is again comment

Многострочные комментарии можно создать так:

.. code::

    # This is a comment.
    # This is a comment, too.
    # This is a comment, too.
    # I said that already.

Или так:

.. code::

    '''Line one
    second line
    third line'''

-----------------
**Пустые строки**
-----------------

Пустые строки, или строки содержащие только пробелы, или строки с комментариями,
игнорируются интерпретатором.

В интерактивной сессии интерпретатора, необходимо ввести пустую строку для
завершения многострочного оператора.

Более подробно о том, как правильно оформлять код **Python** можно прочитать в
`PEP8 <http://pep8.ru/doc/pep8/>`_!

*PEP (python enhanced proposal) — заявки на улучшение языка Python.*

----

=================================
**Модель динамической типизации**
=================================

В одном из примеров мы не объявляли тип переменной либо её саму:

.. code::

    name = "Madisetti"

У вас может возникнуть вопрос, как же интерператор **Python** узнает, что речь идет
о строке? И вообще, как **Python** узнает, что есть что?

Для того, чтобы ответить на эти вопросы, необходимо рассмотреть как работает
динамическая типизация в **Python**. Типы данных в **Python** определяются автоматически
во время выполнения, а не в результате объявлений в программном коде. Это означает,
что вам не требуется заранее объявлять переменные (эту концепцию проще понять, если
иметь в виду, что все сводится к переменным, объектам и ссылкам между ними).

**Создание переменной**

Переменная (т.е. имя или идентификатор), такая как *name*, создается автоматически,
когда в программном коде ей впервые присваивается некоторое значение. Все последующие
операции присваивания просто изменяют значение, ассоциированное с уже созданным
именем.

**Типы переменных**

Переменные не имеют никакой информации о типе или ограничениях, связанных с ними.
Понятие типа присущие объектам, а не именам. Переменные универсальны по своей природе -
они всегда являются всего лишь ссылками на конкретные объекты в конкретные моменты
времени.

**Использование переменной**

Когда переменная участвует в выражении, ее имя замещается объектом, на который
она в настоящий момент ссылается, независимо от того, что это за объект. Кроме
того, прежде чем переменную можно будет использовать, ей должно быть присвоено
значение - использование неицициализированной переменной приведет к ошибке
(*NameError: name 'name' is not defined*).

Для того чтобы понимать что происходит при присваивании некого значения переменной,
рассмотрим такой пример:

.. code::

    a = 3

**Python** выполнит эту инструкцию в три этапа, концептуально.

1. Cоздается объект, представляющий число 3.
2. Создается пременная *a*, если она еще отсутствует.
3. В переменную *a* записывается ссылка на вновь созданный объект, представляющий число 3.

**Информация о типе хранится в объекте, но не в переменной.**

Допустим, у нас есть следующий пример:

.. code::

    a = 3
    a = 'spam'
    a = 1.23

Как уже указывалось ранее, имена не имеют типов, тип - это свойство объекта, а не
имени. В предыдущем листинге просто изменяется ссылка на объект. Все что можно
сказать о перменных в языка **Python** - это то, что они создаются на конкретные
объекты в конкретные моменты времени.

Объекты знают, к какому типу они относятся, - каждый объект содержит поле, в котором
хранится информация о его типе. Целочисленный объект 3, например, будет содержать
значение 3 плюс информацию, которая сообщит интерпретатору **Python**, что объект
является целым числом (строго говоря - это указатель на объект с названием *int*).
Описатель типа для строки 'spam' указывает на строковой тип (с именем *str*).
Поскольку информация о типе хранится в объектах, ее не нужно хранить в переменных.

У кого-то может возникнуть вопрос: что происходит с прежними значениями, когда
выполняется новое присваивание?
Например, что произойдет с объектом 3 после выполнения следующих инструкций:

Основная выгода от сборки мусора состоит в том, что вы может свободно распоряжаться
объектами, не будучи обязаны освбождать память в своем сценарии.

.. code::

    a = 3
    a = 'spam'

Когда имя ассоциируется с новым объектом, интепретатор **Python** освобождает
память, занимаемую предыдущим объектом (если на него не ссылается какое-либо другое
имя или объект). Такое автоматическое освобождение памяти, занимаемой объектами,
называется *сборкой мусора (garbage collection)*.

----------------------
**Разделяемые ссылки**
----------------------

До сих пор мы рассматривали вариант, когда ссылка на объект присваивается
единственной переменной. Теперь введем в действие еще одну переменную и посмотрим,
что происходит с именами и объектами в это случае:

.. code:

    a = 3
    b = a

.. figure:: /images/links-1.png
    :height: 123px
    :width: 556px
    :scale: 100%
    :align: center
    :alt: Python Links to one object

В языке **Python** это называется *разделяемая ссылка* - несколько имен ссылаются
на один и тот же объект.

Далее добавим еще одну инструкцию:

.. code::

    a = 3
    b = a
    a = 'spam'

В результате выполнения этой инструкции создается новый объект, представляющий
строку 'spam', а ссылка на него записывается в переменную *a*. Однако эти действия
не оказывают влияния на переменную *b* - она по-прежнему ссылается на первый
объект, целое число 3. В результате схема взаимоотношений приобретает вид:

.. figure:: /images/links-2.png
    :height: 188px
    :width: 554px
    :scale: 100%
    :align: center
    :alt: Python Links to two objects

То же самое произошло бы, если бы ссылка на объект 'spam' вместо переменной *a*
была присвоена переменной *b* - изменилась бы только переменная *b*, но не *а*.
Аналогичная ситуация возникает, даже если тип объекта не изменяется.
Например, рассмотрим следующие три инструкции:

.. code::

    a = 3
    b = a
    a = a + 2

В этой последовательности происходит те же самые события: интепретатор **Python**
создает переменную *a* и записывает в нее ссылку на объект *3*. После этого он
создает переменную *b* и записывает в нее ту же ссылку, что хранится в переменной
*a*. Наконец, последняя инструкция создает совершенно новый объект (в данном случае -
целое число 5, которое является результатом выполнения операции сложения). Это не
приводит к изменению переменной *b*. В действительности нет никакого способа
перезаписать значение объекта 3, целые числа относятся к категории неизменяемых
(*подробнее о категориях и типов данных далее*), и поэтому эти объекты невозможно
изменить.

-------------------------------------------
**Разделяемые ссылки и изменяемые объекты**
-------------------------------------------

Как будет показано дальше в этом цикле статей, существуют такие объекты и операции,
которые приводят к изменению самих объектов. Например, операции присваивания значения
элементу списка фактически изменяют сам список вместо того, чтобы создавать совершенно
новый объект списка. При работе с объектами, допускающими такие изменения, необходимо
быть особенно внимательными при использовании разделяемых ссылок, так как изменение
одного имени может отразиться на других именах.

Возьмем в качестве примера объекты списков (будут рассмотрены подробно в следующей
части). Списки, поддерживают возможность присваивания значений элементам, - это
просто коллекция объектов, которые в программном коде записываются как литералы
в квадратных скобках:

.. code::

    L1 = [2, 3, 4]
    L2 = L1

В данном случае *L1* - это список, содержащий объекты 2, 3 и 4. Доступ к элементам
списка осуществляется по их индексам; так, *L1[0]* - ссылается на объект 2, т.е. на
первый элемент в списке *L1*. Cписки являются полноценными объектами, такими же,
как целые числа и строки. После выполнения двух приведенных выше инструкций
*L1* и *L2* будут ссылаться на один и тот же объект, так же, как переменные *a* и
*b* в примере выше. Точно так же, если теперь добавить еще одну инструкцию:

.. code::

    L1 = 24

Переменная *L1* будет ссылаться на другой объект, а L2 по-прежнему будет ссылаться
на первоначальный список. Однако если синтаксис последней инструкции немного изменить,
эффект получится другим:

.. code::

    L1 = [2, 3, 4]
    L2 = L1
    L1[0] = 24

    L1 # Переменная L1 изменилась
    [24, 3, 4]
    L2 # Но так же изменилась и переменная L2
    [24, 3, 4]

Здесь мы не изменяем сам объект *L1*, изменяется компонент объекта, на который
ссылается *L1*. Данное изменение затронуло часть самого объекта списка. Поскольку
объект списка разделяется разными переменными, то изменения в самом списке затрагивают
не только *L1*, т.е. следует понимать, что такие изменения могут сказываться в
других частях программы. В этом примере изменения обнаруживаются также в переменной
*L2*, потому что она ссылается на тот же самый объект, что и *L1*. Здесь мы фактически
не изменяли *L2*, но значение этой переменной изменилось.

Это поведение по умолчанию: если вас оно не устраивает, можно потребовать от
интерпретатора, чтобы вместо создания ссылок он выполнял копирование объектов.
Скопировать список можно несколькими способами, включая встроенную функцию *list* и
модуль *copy* из стандартной библиотеки. Однако самым стандартным способом
копирования является получение среза (так же будет рассмотрено в следующих частях)
от начала и до конца списка.

.. code::

    L1 = [2, 3, 4]
    L2 = L1[:] # Создание копии списка L1
    L1[0] = 24

    L1
    [24, 3, 4]
    L2 # Не изменился
    [2, 3, 4]

**Будьте внимательны**, что способ, основанный на получении среза, неприменим в
случае с другими изменяемым базовым типом - со словарем (будет рассмотрен подробно
в следущей части), потому что словарь не является последовательностью. Чтобы
скопировать словарь, необходимо воспользоваться методом X.copy(). Следует также
отметить, что модуль *copy* из стандартной библиотеки имеет в своем составе
универсальную функцию, позволяющую копировать объекты любых типов, включая
вложенные структуры (например, словари с вложенными списками).

.. code::

    import copy
    x = copy.copy(y) # Создание "поверхностной" копии любого объекта y
    x = copy.deepcopy(y) # Создание полной копии: копируются все вложенные части

----------------------------------
**Разделяемые ссылки и равенство**
----------------------------------

Возможность сборки мусора, описанная ранее, может оказаться более принципиальным
понятием, чем литералы для объектов некоторых типов.

.. code::

    x = 42
    x = "shrubbery" # Объект 42 теперь уничтожен?

Так как интерпретатор **Python** кэширует и повторно использует малые целые числа и
небольшие строки, объект 42 скорее всего не будет уничтожен. Он, вероятнее всего,
останется в системной таблице для повторного использования, когда вы вновь сгенерируете
число 42 в программном коде. Однако большинство объектов уничтожаются немедленно,
как только будет потеряна последняя ссылка, особенно те, к которым применение
механизма кэширования не имеет смысла.

Согласно модели ссылок в языке **Python**, существует два разных способа выполнять
проверку равенства.

.. code::

    l = [1, 2, 3]
    n = l # n и l - ссылки на один и тот же объект
    l == n # Одно и то же значение
    True
    l is n # Один и тот же объект
    True

Первый способ, основанный на использовании оператора ==, проверяет, равны ли значения
объектов. В языке **Python** практически всегда используется именно этот способ.
Второй способ, основанный на использовании оператора *is*, проверяет идентичность
объектов. Он возвращает значение *True*, только если оба имени ссылаются на один и
тот же объект, вследствие этого он является более строгой формой проверки равенства.

На самом деле оператор *is* просто сравнивает указатели, которые реализуют ссылки,
и тем самым может использоваться для выявления разделяемых ссылок в программном
коде. Он возвращает значение *False*, даже если имена ссылаются на эквивалентные,
но разные объекты, как, например, в следующем случае, когда выполняются два
различных литеральных выражения:

.. code::

    l = [1, 2, 3]
    n = [1, 2, 3] # n и l ссылаются на разные объекты
    l == n # Одно и то же значение
    True
    l is n # Но разные объекты
    False

Посмотрим, что происходит, если те же самые действия выполняются над малыми целыми
числами:

.. code::

    x = 42
    y = 42 # Должно получиться два разных объекта
    x == y
    True
    x is y # Тот же самый объект: кэширование в действии!
    True

В этом примере переменные *x* и *y* должны быть равны, но не эквивалентны, потому
что было выполнено два разных литеральных выражения. Однако из-за того, что малые
целые числа и строки кэшируются и используются повторно, оператор *is* сообщает,
что переменные ссылаются на один и тот же объект.

Фактически если вы действительно хотите взглянуть на работу внутренних механизмов,
вы всегда можете запросить у интерпретатора количество ссылок на объект: функция
*getrefcount* из стандартного модуля *sys* возвращает значение поля счетчика ссылок
в объекте.

.. code::

    import sys
    sys.getrefcount(1) # 810 указателей на этот участок памяти
    810

----

На этом сегодняшняя статья окончена. В следующий раз рассмотрим типы данных.
