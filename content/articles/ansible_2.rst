.. |date| date:: %Y-%m-%d

:title: Ansible
:date: 2017-01-30
:modified: |date|
:author: Artur K.
:category: Administration
:tags: ansible, python, linux
:slug: ansible
:status: draft





=============================
**Управление конфигурациями**
=============================

--------------
**Playbooks**
--------------

Исполнение *Playbooks* - одна из основных задач **Ansible**. *Playbooks* содержат
списки задач. Каждая задача внутри **Ansible** использует кусок кода-модуля.
*Playbooks* описываются в формате *YAML*.

Чтобы выполнить сценарий используется команда ansible-playbook со следующим
синтаксисом:

.. code::

    ansible-playbook <имя_файла_сценария.yml> ... [другие параметры]

--------
**YAML**
--------

Для **Ansible** практически каждый *YAML* файл начинается со списка. Каждый
элемент списка - список пар "ключ-значение", часто называемая словарем.

Все *YAML* файлы должны начинаться с "---". Это часть формата *YAML* и означает
начало документа.

Все члены списка должны находится с одинаковым отступом от начала строки, и
должны начинаться с пробела или "-". Комментарии начинаются с "#".

Например:

.. code::

    ---
    # Message
    - Hosting
    – Cloud

Словарь представлен в виде "ключ" (двоеточие и пробел) "значение":

.. code::

    ---
    # Message
    site: site_test
    blog: blog_test

При необходимости словари могут быть представлены в сокращенной форме:

.. code::

    ---
    # Comment
    {site: site_test, blog: blog_test}

Можно указать логические значение (истина/ложь) так:

.. code::

    ---
    need_access: no
    use_service: yes
    file_conf: TRUE
    read_value: True
    kill_process: false

Целиком *YAML*-файл будет выглядеть так:

.. code::

    ---
    # About blog
    site: site_test
    blog: blog_test
    must_read: True
    themes:
        - hosting
        - cloud
        - it
        - geeks
    brands:
        - blog_test
        - blog_test_cloud

Для переменных **Ansible** используют "{{ var }}". Если значение после двоеточия
начинается с "{", то *YAML* будет думать, что это словарь.

Для использования переменных нужно заключить скобки в кавычки:

.. code::

    word: "{{ variable }}"

-----------------------
**Написание playbooks**
-----------------------

*Playbooks* может состоять из списка обсуживаемых серверов, переменных
пользователя, задач, обработчиков (handlers) и т.д. Большинство настроек
конфигурации можно переопределить в *playbook*. Каждый *playbook* состоит из одного
или более действий (игры) в списке.

Цель игры - связать группу хостов с предопределенными ролями, представленными
как вызов задач **Ansible**.

В качестве примера рассматривается процесс установки *nginx*.
Создадим директорию, где будут хранится *playbooks*:

.. code::

    mkdir ~/ansible/playbooks

Создадим файл *setup_nginx.yml* в директории *playbooks* со следующим содержанием:

.. code::

    ---
    - hosts: dbservers
      tasks:

      - name: Install nginx package
        apt: name=nginx update_cache=yes
        sudo: yes

      - name: Starting nginx service
        service: name=nginx state=started
        sudo: yes

Рассмотрим подробнее содержимое:

- **hosts:** Список хостов или группа, на которой вы запускаете задачу. Это поле обязательное и каждый *playbook* должен иметь его, за исключением ролей. Если указана хост-группа, сначала **Ansible** ее ищет в *playbook*, а затем в файле *inventory*. Узнать, на каких хостах будет происходить работа, можно командой: *ansible-playbook --list-host*, где – путь к вашему *playbook (playbooks/setup_nginx.yml)*.
- **tasks:** Задачи. Все *playbooks* содержат задачи. Задача — это список действий, которые вы хотите выполнить. Поле задачи содержит имя задачи (справочная информация о задаче для пользователя *playbook*), модуль, который должен быть выполнен и аргументы, требуемые для модуля. Параметр «name» опциональный, но рекомендуемый.

Также в сценарии перед непосредственным описанием задачи могут указыватся
следующие параметры или группы параметров:

- **gather_facts** - собирать или нет информацию о хостах перед выполнением задач, по умолчанию - да;
- **vars** - в нем указываются различные переменные, которые будут использованы при выполнении сценария;
- **connection** - можно указать метод соединения с хостами: *pure ssh*, *paramiko*, *fireball*, *chroot*, *jail*, *local*, *accelerate* (применимо также для выполнения отдельного модуля);
- **sudo** - после установления соединения выполнять задачу с привелегиями другого пользователя, по умолчанию другой пользователь - *root*;
- **sudo_user** - в сочетании с предыдущим параметром можно указать с привелегиями какого именно пользователя будет выполнена задача;
- **vars_prompt** - перед выполнением *playbook'a* **Ansible** в интерактивном режиме, может уточнить указанные в этом разделе параметры;
- **remote_user** (в предыдущих версиях - просто *user*) - имя пользователя для авторизации на удаленном хосте.

----------------
**Шаблонизация**
----------------

В **Ansible** используется шаблонизатор `Jinja2 <http://jinja.pocoo.org/>`_.

Пример сценария в yml-файле:

.. code::

    ---
    - hosts: all
    user: ubuntu

    tasks:
    - name: Update apt cache
      apt: update_cache=yes
      sudo: yes

    - name: Install required packages
      apt: name={{ item }}
      sudo: yes
      with_items:
        - nginx
        - postgresql

Если необходимо установить несколько пакетов при этом с одинаковыми настройками
- используется шаблонизатор и параметр with_items.

---------------------------------
**Обработчик событий (Handlers)**
---------------------------------

**Ansible** не просто выполняет задачи в указанном порядке, но и проверяет их
состояние на наличие изменений. Если при выполнении сценария требовалось,
например, добавить строку в конфигурационный файл, и в результате выполнения
он изменился (необходимой строки действительно не было), то **Ansible** может
выполнить специальную задачу, описанную как обработчик события (*handler*).
Если при выполнении строка уже была в конфигурационном файле, то обработчик
выполнен не будет. Обработчики событий описываются в конце сценария; в описании
задачи они указываются через параметр *notify*.

Пример:

.. code:: yaml

    ---
    - hosts: webservers
      vars:
        max_clients: 200

    tasks:
      # сгенерируем файл конфигурации на основе шаблона
      # и укажем, что требуется выполнить задачу “restart apache”
      # если файл изменился
    - name: write the apache config file
      template: src=/srv/httpd.j2 dest=/etc/httpd.conf
      notify:
      - restart apache

    - name: ensure apache is running
      service: name=httpd state=started

    # раздел описания обработчиков
    handlers:
      - name: restart apache
        # используем модуль service для перезапуска веб-сервера
        service: name=httpd state=restarted

-----------------------
**Контроль выполнения**
-----------------------

Допустим, что при выполнении сценария нам нужно проверять определённые
переменные или состояния и, в зависимости от них, выполнять или не выполнять
какие-либо задачи. Для этого можно использовать оператор *“when”*:

.. code::

    tasks:
      # сохраняем файл шаблона и сохраняем результат задачи
      # в переменную last_result
    - template: src=/templates/foo.j2 dest=/etc/foo.conf
      register: last_result
      # проверяем переменную last_result.changed и если она имеет
      # значение true - задача будет выполнена, иначе - будет пропущена
    - command: echo 'the file has changed'
      when: last_result.changed

--------------------------------------
**Делегирование задачи другому хосту**
--------------------------------------

Иногда требуется выполнить задачу на определённом узле, но в контексте другого
узла. Например, во время обновления узла может возникнуть необходимость отключить
для него мониторинг, находящийся на отдельном сервере. Для этого используется
управляющая директива *delegate_to*. Приведём пример:

.. code::

    - name: disable nagios alerts for this host webserver service
    nagios: action=disable_alerts host={{inventory_hostname}} services=dnsserver
    delegate_to: mon_host.example.com

Результатом выполнения этой задачи будет отключение сообщений для сервиса
dnsserver в Nagios.

--------
**Роли**
--------

Ролью называется типовой набор переменных и задач, назначаемых для одного или
нескольких серверов. Если вам нужно применить к серверу или группе серверов
типовой набор операций, вам достаточно просто назначить ему роль. Предварительно
в проекте каталоге проекта должна быть создана соответствующая структура. В
сценариях роли назначаются следующим образом:

.. code::

    ---
    - name: check and apply basic configuration to all hosts
      hosts: all
      roles:
        - common

    - name: check and apply configuration to group1
      hosts: group1
      roles:
        - pgsql

    - name: check and apply configuration to group2
      hosts: group2
      roles:
        - fooapp

=====================
**Структура проекта**
=====================

.. code::

    ├── production                # инвентарный файл для продакшн-серверов
    ├── stage                     # инвентарный файл для stage-окружения
    │
    ├── group_vars/
    │   ├── group1                # здесь назначаются переменные для
    │   └── group2                # конкретных групп
    ├── host_vars/
    │   ├── hostname1             # специфические переменные для хостов в
    │   └── hostname2             # случае необходимости прописываются здесь
    │
    ├── site.yml                  # основной сценарий
    ├── webservers.yml            # сценарий для веб-сервера
    ├── dbservers.yml             # сценарий для сервера базы данных
    │
    └── roles/
    ├── common/               # здесь описываются роли
    │   ├── tasks/            #
    │   │   └── main.yml      # - файл задач роли, может включать файлы
    │   │                     #   меньшего размера
    │   ├── handlers/         #
    │   │   └── main.yml      # - файл с обработчиками (handlers)
    │   ├── templates/        # - директория для шаблонов, в данном
    │   │   └── ntp.conf.j2   #   случае - для конфига ntp
    │   ├── files/            #
    │   │   ├── bar.txt       # - файл-ресурс для копирования на хост
    │   │   └── foo.sh        # - скрипт для выполнения на удалённом хосте
    │   └── vars/             #
    │       └── main.yml      # - ассоциированные с ролью переменные
    │
    ├── pgsql/                # такая же структура, как выше, для роли pgsql
    └── fooapp/               # такая же структура, как выше, для роли fooapp

==============
Модули Ansible
==============

Модуль можно написать на любом языке, он должен уметь принимать параметры на
вход и выдавать json ответ. Модули находятся `здесь <http://docs.ansible.com/ansible/list_of_all_modules.html>`_.

Как написать свой собственный модуль, можно прочитать в `документации <http://docs.ansible.com/ansible/dev_guide/developing_modules.html>`_.


В состав Ansible входит огромное количество модулей для развёртывания,
контроля и управления различными компонентами, которые можно условно разделить
на следующие группы (в скобках приведены названия некоторых продуктов и
сервисов):

- облачные ресурсы и виртуализация (Openstack, libvirt);
- базы данных (MySQL, Postgresql, Redis, Riak);
- файлы (шаблонизация, регулярные выражения, права доступа);
- мониторинг (Nagios, monit);
- оповещения о ходе выполнения сценария (Jabber, Irc, почта, MQTT, Hipchat);
- сеть и сетевая инфраструктура (Openstack, Arista);
- управление пакетами (apt, yum, rhn-channel, npm, pacman, pip, gem);
- система (LVM, Selinux, ZFS, cron, файловые системы, сервисы, модули ядра);
- работа с различными утилитами (git, hg).
