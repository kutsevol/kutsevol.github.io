:title: Ansible Introduction. Part 3
:date: 2017-02-21
:modified: 2017-02-21
:author: Artur K.
:category: Administration
:tags: ansible, python, linux
:slug: ansible_end
:status: draft

.. contents:: **Содержание**
   :depth: 3

----

==========
**Модули**
==========

Модуль можно написать на любом языке, он должен уметь принимать параметры на
вход и выдавать json ответ. Модули находятся `здесь <http://docs.ansible.com/ansible/list_of_all_modules.html>`_.

Как написать свой собственный модуль, можно прочитать в `документации <http://docs.ansible.com/ansible/dev_guide/developing_modules.html>`_.

В состав Ansible входит огромное количество модулей для развёртывания,
контроля и управления различными компонентами, которые можно условно разделить
на следующие группы (в скобках приведены названия некоторых продуктов и
сервисов):

- облачные ресурсы и виртуализация (Openstack, libvirt);
- базы данных (MySQL, Postgresql, Redis, Riak);
- файлы (шаблонизация, регулярные выражения, права доступа);
- мониторинг (Nagios, monit);
- оповещения о ходе выполнения сценария (Jabber, Irc, почта, MQTT, Hipchat);
- сеть и сетевая инфраструктура (Openstack, Arista);
- управление пакетами (apt, yum, rhn-channel, npm, pacman, pip, gem);
- система (LVM, Selinux, ZFS, cron, файловые системы, сервисы, модули ядра);
- работа с различными утилитами (git, hg).

----------------------------
**Командный модуль command**
----------------------------

Модуль принимает имя команды и армументы. Переменные оболочки или операции (<,>,|,&)
не будут работать с модулем command, т.к. обрабатываются оболочкой.
Модуль command принимает следующие параметры:

- *chdir*: Используется для изменения текущей директории, в которой исполняется команда
- *creates*: Создает файл
- *removes*: Удаляет файл

Простейшая задача перезагрузки сервера:

.. code::

    - name: Reboot machine
        command: /sbin/shutdown -r now
        sudo: yes

------------------------
**Командный модуль raw**
------------------------

Этот модуль следует использовать, когда другие командные модули использовать не удается.
Это простой запуск удаленных команд серверу по *SSH*. Данный модуль работает
даже на серверах без установленного *Python*.

Пример установки пакета *vim*:

.. code::

    - name: Install vim
        raw: yum -y install vim-common
        sudo: yes

По окончанию выполнения операции, можно будет увидеть, что пакет установлен, но
задача не будет помечена как *changed*. Лучше не использовать *raw* модуль когда возможно.

---------------------------
**Командный модуль script**
---------------------------

Этот модуль используется для копирования скрипта на удаленную машину и исполнения его.
Модуль поддерживает параметры *creates* и *removes*.

Для примера, напишем скрипт для просмотра количества директорий в */etc* и запустим
его на удаленных серверах (~/ansible/playbooks/scripts/**list_number_of_directories.sh**)

.. code::

    #/bin/bash
    ls -l /etc | egrep '^d' | wc -l

Задача, использующая модуль script выглядит так:

.. code::

    - name: List directories in /etc
        script: ~/ansible/playbooks/scripts/list_number_of_directories.sh /etc
        sudo: yes

Путь к файлу скрипта задается относительно месторасположения файла, использующего
модуль *script*. Например, если данная задача описана в файле задачи,
импортированном в *playbook*, расположение скрипта задается относительно файла
задачи, а не *playbook*.

--------------------------
**Командный модуль shell**
--------------------------

Ключевое отличие модуля *shell* от модуля *command* в том, что он использует
**/bin/sh** по умолчанию для запуска команд. Вы можете использовать переменные
оболочки и другие функции оболочки.

------------------------
**Файловый модуль file**
------------------------

Модуль *file* позволяет вам изменять атрибуты файла. Можно создать файл, создать
или удалить директории рекурсивно, создать или удалить символическую ссылку.

Проверим, что httpd.conf имеет правильные права владельца:

.. code::

    - name: Ensure httpd conf has right permissions and owner/group
        file: path=/etc/httpd/conf/httpd.conf owner=root group=root mode=0644
        sudo: yes

Так как скрипты **Ansible** позволяют достичь нужного состояния и при перезапуске
скриптов - повторный запуск позволит убедиться и поправить при необходимости права
на доступ к файлам.

Как создаются *симлинки*:

.. code::

    - name: Create a symlink in /tmp for httpd.conf
        file: src=/etc/httpd/conf/httpd.conf dest=/tmp/httpd.conf owner=root group=root state=link
        sudo: yes

Создание директории рекурсивно:

.. code::

    - name: Create recursive directories
        file: path=/tmp/dir1/dir2/dir3 owner=root group=root mode=0777
        sudo: yes

------------------------
**Файловый модуль copy**
------------------------

С помощью модуля *copy* можно копировать файлы на сервер.

.. code::

    - name: Copy file remotely
        copy: src=test2.conf dest=/etc/test2.conf owner=root group=root mode=0644
        sudo: yes

------------------------------------------
**Модуль системы управления версиями git**
------------------------------------------

В **Ansible** есть поддержка различных систем управления версиями (*svn*, *bzr*,
*hg* и другие), но рассмотрим *git*:

Установка *git* на сервер:

.. code::

    - yum: name=git state=installed
      sudo: yes

Получим репозиторий со скриптами из этих статей:

.. code::

    - name: Checkout ansible–playground repository
        git: repo=https://github.com/trukhinyuri/ansible-playground.git dest=~/checkout
        sudo: yes

До и после выполнения задачи считается *SHA*, который позволяет понять, был ли
репозиторий обновлен.

Если получаете файлы по *SSH* - используйте параметры **accept_key** и **key_file**
для установки ключа для доступа к репозиторию. Если нужно использовать ключ
*accept_key=yes*, *key_file* - указывает на путь к ключу. Если ключ находится в
*~/.ssh* - указывать *key_file* не нужно.

=================================================
**Запуск задачи локально с помощью local_action**
=================================================




========
**Роли**
========

Ролью называется типовой набор переменных и задач, назначаемых для одного или
нескольких серверов. Если вам нужно применить к серверу или группе серверов
типовой набор операций, вам достаточно просто назначить ему роль. Предварительно
в проекте каталоге проекта должна быть создана соответствующая структура. В
сценариях роли назначаются следующим образом:

.. code::

    ---
    - name: check and apply basic configuration to all hosts
      hosts: all
      roles:
        - common

    - name: check and apply configuration to group1
      hosts: group1
      roles:
        - pgsql

    - name: check and apply configuration to group2
      hosts: group2
      roles:
        - fooapp

=====================
**Структура проекта**
=====================

.. code::

    ├── production                # инвентарный файл для продакшн-серверов
    ├── stage                     # инвентарный файл для stage-окружения
    │
    ├── group_vars/
    │   ├── group1                # здесь назначаются переменные для
    │   └── group2                # конкретных групп
    ├── host_vars/
    │   ├── hostname1             # специфические переменные для хостов в
    │   └── hostname2             # случае необходимости прописываются здесь
    │
    ├── site.yml                  # основной сценарий
    ├── webservers.yml            # сценарий для веб-сервера
    ├── dbservers.yml             # сценарий для сервера базы данных
    │
    └── roles/
    ├── common/               # здесь описываются роли
    │   ├── tasks/            #
    │   │   └── main.yml      # - файл задач роли, может включать файлы
    │   │                     #   меньшего размера
    │   ├── handlers/         #
    │   │   └── main.yml      # - файл с обработчиками (handlers)
    │   ├── templates/        # - директория для шаблонов, в данном
    │   │   └── ntp.conf.j2   #   случае - для конфига ntp
    │   ├── files/            #
    │   │   ├── bar.txt       # - файл-ресурс для копирования на хост
    │   │   └── foo.sh        # - скрипт для выполнения на удалённом хосте
    │   └── vars/             #
    │       └── main.yml      # - ассоциированные с ролью переменные
    │
    ├── pgsql/                # такая же структура, как выше, для роли pgsql
    └── fooapp/               # такая же структура, как выше, для роли fooapp
